# Запуск приложения

Это приложение разработано с использованием `PyQt6` и предназначено для взаимодействия с `API`. В этом документе описаны шаги, необходимые для запуска приложения.

### Структура проекта

```
frontend/
│
├── app/
│   ├── main.py              # Основной файл приложения
│   ├── start_tests.py       # Точка входа для запуска тестов
│   ├── __init__.py
│   │
│   ├── config/              # Конфигурационные файлы
│   │   ├── literals.py      # Литералы и константы
│   │   ├── paths.py         # Определение путей
│   │   ├── __init__.py
│   │   └── api/             # Конфигурация API
│   │       ├── api_config.py
│   │       ├── endpoints_config.py
│   │       └── __init__.py
│   │
│   ├── dependencies/        # Зависимости приложения
│   │   ├── app.py           # Основные зависимости приложения
│   │   ├── ui_helper.py     # Вспомогательные функции для UI
│   │   └── __init__.py
│   │
│   ├── exceptions/          # Обработчики исключений
│   │   ├── exception_handler.py
│   │   └── __init__.py
│   │
│   ├── models/              # Модели данных
│   │   ├── api_models.py    # Модели для API
│   │   └── __init__.py
│   │
│   ├── static/              # Статические файлы
│   │   ├── __init__.py
│   │   └── img/             # Изображения
│   │       └── icon.png
│   │
│   ├── tests/               # Тесты приложения
│   │   ├── test_app.py      # Тесты для основного приложения
│   │   └── __init__.py
│   │
│   └── utils/               # Утилиты и вспомогательные функции
│       ├── requests_utils.py # Утилиты для работы с запросами
│       └── __init__.py
└── README.md
```

## Установка зависимостей

Перед запуском приложения убедитесь, что у вас установлены все необходимые зависимости. Рекомендуется использовать виртуальное окружение для изоляции зависимостей проекта.

### Шаги по созданию и активации виртуального окружения

1. **Создайте виртуальное окружение**:

   В корневой директории проекта выполните следующую команду:

   ```bash
   python -m venv .venv
   ```

   Это создаст директорию `venv`, в которой будет находиться ваше виртуальное окружение.

2. **Активируйте виртуальное окружение**:

   - **На Windows**:

     ```bash
     venv\Scripts\activate
     ```

   - **На macOS и Linux**:

     ```bash
     source venv/bin/activate
     ```

3. **Установите зависимости**:

   После активации виртуального окружения выполните следующую команду для установки необходимых библиотек:

   ```bash
   pip install -r requirements.txt
   ```


## Запуск приложения

1. Перейдите в директорию `frontend/app`:

   ```bash
   cd frontend/app
   ```

2. Запустите приложение с помощью Python:

   ```bash
   python main.py
   ```

## Описание класса StartUp

Класс `StartUp` отвечает за инициализацию и запуск приложения. Он содержит статический метод `start`, который создает экземпляр `QApplication`, инициализирует главное окно приложения с помощью класса `MyApp`, и запускает главный цикл обработки событий.

### Метод `start`

- **Протокол (proto)**: Указывает протокол для API (по умолчанию 'http').
- **Базовый URL (base_url)**: Указывает базовый URL для API (по умолчанию '127.0.0.1:8000').

### Примечание

Метод `start` должен вызываться, когда скрипт запускается напрямую. Он инициализирует приложение и отображает главное окно.

## Примечания

- Убедитесь, что сервер API запущен и доступен по указанному базовому URL, прежде чем запускать приложение.
- Если у вас возникли проблемы с запуском, проверьте, установлены ли все зависимости и правильно ли настроены пути в проекте.


---


# Компиляция в `.exe` файл
Для компиляции в `.exe` необходимо операционная машина локального хоста должна быть Windows
Необходимо иметь установленный [Microsoft C++ Build Tools](https://visualstudio.microsoft.com/ru/visual-cpp-build-tools/)
При установке `Microsoft C++ Build Tools` необходимо дополнительно выбрать `Разработка классических приложений на C++`.

```bash
nuitka --enable-plugin=pyqt6 --follow-imports --standalone --jobs=4 --onefile  --disable-console .\app\main.py
```


---


# Тестовый набор для MyApp

Тестовый набор для приложения `MyApp`, которое построено с использованием `PyQt6`. Тесты предназначены для проверки функциональности приложения, особенно в обработке пользовательского ввода и взаимодействии с `API`.

### Требования

Для запуска тестов необходимо установить зависимости из requirements.txt:

- Python 3.11
- PyQt6
- `unittest` (входит в стандартную библиотеку Python)

### Структура каталогов

```
root_dir/
│
├── app/
│   ├── dependencies/
│   │   └── app.py          # Содержит класс MyApp
│   ├── tests/
│   │   └── test_app.py     # Содержит тесты для MyApp
│   └── start_tests.py      # Точка входа для запуска тестов
└── README.md
```

### Тестовые случаи

Тестовый набор включает в себя следующие тестовые случаи для класса `MyApp`:

1. **test_send_data_success**: Тест успешной отправки пользовательских данных.
2. **test_send_data_empty_input**: Тест поведения при пустом вводе.
3. **test_send_data_api_error**: Тест обработки ошибок API при отправке данных.
4. **test_get_data_success**: Тест успешного получения пользовательских данных.
5. **test_get_data_api_failure**: Тест обработки ошибок API при получении данных.

### Запуск тестов

Чтобы запустить тесты, перейдите в каталог `root_dir` в вашем терминале и выполните следующую команду:

```bash
python app/start_tests.py
```

Это запустит все тестовые случаи, определенные в `test_app.py`, и отобразит результаты в терминале.

### Реализация тестов

Тесты используют фреймворк `unittest` вместе с `unittest.mock` для имитации поведения внешних зависимостей. `QMessageBox` замещается для проверки того, что правильные сообщения отображаются пользователю в зависимости от различных сценариев.

### Пример тестового случая

Вот пример тестового случая из набора:

```python
@patch("app.my_app.Requester.send_request")
def test_send_data_success(self, mock_send_request):
    """Тест успешной отправки данных"""
    mock_send_request.return_value = {"status": 200}
    self.app.ui_helper = MagicMock()
    self.app.ui_helper.line_edit.text.return_value = "John Doe"

    with patch.object(QMessageBox, "information") as mock_info:
        self.app.send_data()
        mock_info.assert_called_with(self.app, '✅', 'Пользователь успешно создан!')
```